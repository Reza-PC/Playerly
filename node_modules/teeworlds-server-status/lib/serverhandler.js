"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerHandler = void 0;
var dgram_1 = __importDefault(require("dgram"));
var crypto_1 = __importDefault(require("crypto"));
var ServerHandler = /** @class */ (function () {
    function ServerHandler(address, port, ignoreToken, timeout) {
        if (port === void 0) { port = 8303; }
        if (ignoreToken === void 0) { ignoreToken = false; }
        if (timeout === void 0) { timeout = 100; }
        this.port = 8303;
        this.address = address;
        this.port = port;
        this.ignoreToken = ignoreToken;
        this.timeout = timeout;
    }
    ServerHandler.prototype.requestInfo = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var socket = dgram_1.default.createSocket('udp4');
            socket.on('error', function (err) {
                reject(err);
            });
            var token;
            var extraToken;
            var timeoutID;
            socket.on('listening', function () { return __awaiter(_this, void 0, void 0, function () {
                var res;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.sendRequest(socket)];
                        case 1:
                            res = _a.sent();
                            token = res.token;
                            extraToken = res.extraToken;
                            timeoutID = setTimeout(function () {
                                socket.close();
                                reject(new Error("Timed out after " + _this.timeout + " milliseconds."));
                            }, this.timeout);
                            return [2 /*return*/];
                    }
                });
            }); });
            socket.on('message', function (msg, rinfo) {
                if (rinfo.address === _this.address && rinfo.port === _this.port) {
                    clearTimeout(timeoutID);
                    socket.close();
                    try {
                        var serverInfo = _this.parsePacket(msg, token, extraToken);
                        resolve(serverInfo);
                    }
                    catch (err) {
                        reject(err);
                    }
                }
            });
            socket.bind();
        });
    };
    ServerHandler.prototype.sendRequest = function (socket) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var buffer = Buffer.alloc(15);
            buffer.write('xe', 0, 2);
            crypto_1.default.randomFillSync(buffer, 2, 2);
            buffer.fill(0xff, 6, 10);
            buffer.write('gie3', 10, 4);
            crypto_1.default.randomFillSync(buffer, 14, 1);
            var extraToken = buffer.readUIntBE(2, 2);
            var token = buffer.readUIntBE(14, 1);
            socket.send(buffer, _this.port, _this.address, function (err, bytes) {
                if (err)
                    reject(err);
                resolve({ token: token, extraToken: extraToken, bytes: bytes });
            });
        });
    };
    ServerHandler.prototype.parsePacket = function (buffer, sentToken, sentExtraToken) {
        var type = buffer.subarray(10, 14).toString();
        var initClients = false;
        var stype = '';
        if (type === 'inf3') {
            type = 'vanilla';
            initClients = true;
        }
        else if (type === 'dtsf') {
            type = '64legacy';
        }
        else if (type === 'iext') {
            type = 'ext';
            initClients = true;
        }
        else if (type === 'iex+') {
            type = 'extmore';
            stype = 'ext';
        }
        if (!stype) {
            stype = type;
        }
        var slots = String(buffer.subarray(14, buffer.length)).split('\x00');
        // debug(slots)
        var token = parseInt(slots.shift(), 10);
        if ((token & 0xff) !== sentToken) {
            if (!this.ignoreToken) {
                throw new Error('Server sent an invalid token.');
            }
        }
        if (stype === 'ext') {
            if ((token & 0xffff00) >> 8 !== sentExtraToken) {
                if (!this.ignoreToken) {
                    throw new Error('Server sent an invalid extraToken.');
                }
            }
        }
        var serverInfo = {
            version: '',
            clientCount: 0,
            gameType: '',
            map: '',
            maxClientCount: 0,
            maxPlayerCount: 0,
            name: '',
            password: false,
            playerCount: 0,
            clients: [],
        };
        if (type !== 'extmore') {
            serverInfo.version = slots.shift();
            serverInfo.name = slots.shift();
            serverInfo.map = slots.shift();
            if (type === 'ext') {
                serverInfo.mapcrc = parseInt(slots.shift(), 10);
                serverInfo.mapsize = parseInt(slots.shift(), 10);
            }
            serverInfo.gameType = slots.shift();
            serverInfo.password = parseInt(slots.shift(), 10) === 1;
            serverInfo.playerCount = parseInt(slots.shift(), 10);
            serverInfo.maxPlayerCount = parseInt(slots.shift(), 10);
            serverInfo.clientCount = parseInt(slots.shift(), 10);
            serverInfo.maxClientCount = parseInt(slots.shift(), 10);
        }
        var clientnum = 0;
        if (type === '64legacy') {
            clientnum = this.unPackInt(slots);
            if (clientnum < 0 || clientnum >= 64) {
                return null;
            }
        }
        var packetnum = 0;
        if (type === 'extmore') {
            packetnum = parseInt(slots.shift(), 10);
            // 0 is reserved for the main ext packet
            if (packetnum <= 0 || packetnum >= 64) {
                return null;
            }
        }
        var reserved;
        var clientPackets = [];
        var clientNumbers = [];
        if (type === 'ext') {
            reserved = slots.shift();
            if (!(packetnum in clientPackets))
                clientPackets.push(packetnum);
            else
                return null;
        }
        while (true) {
            if (slots.length === 0)
                break;
            if (type === 'vanilla' && serverInfo.clientCount === 16)
                break;
            if (serverInfo.clientCount === 64)
                break;
            var addClient = true;
            if (type === '64legacy') {
                if (!clientNumbers) {
                    clientNumbers = [];
                }
                if (!(clientnum in clientNumbers))
                    clientNumbers.push(clientnum);
                else
                    addClient = false;
            }
            // Check if slots is enough big so that it contains another player
            if (slots.length < 5)
                break;
            var client = {
                name: slots.shift(),
                clan: slots.shift(),
                country: parseInt(slots.shift(), 10),
                score: parseInt(slots.shift(), 10),
                isSpectator: parseInt(slots.shift(), 10) === 0,
            };
            if (type === 'ext')
                slots.shift();
            if (addClient) {
                serverInfo.clients.push(client);
                serverInfo.clientCount++;
            }
            clientnum++;
        }
        return serverInfo;
    };
    ServerHandler.prototype.unPackInt = function (slots) {
        var src = slots[0];
        if (src === '') {
            slots.shift();
            return 0;
        }
        var offset = 0;
        var byte = src[offset];
        var sign = (byte >> 6) & 0x01;
        var value = byte & 0x3f;
        while (true) {
            if (!(byte & 0x80))
                break;
            offset++;
            byte = src[offset];
            value |= (byte & 0x7f) << (offset * 7 - 1);
            if (offset === 4)
                break;
        }
        slots[0] = src.substring(0, offset + 1);
        if (sign) {
            value = -value;
        }
        return value;
    };
    return ServerHandler;
}());
exports.ServerHandler = ServerHandler;
